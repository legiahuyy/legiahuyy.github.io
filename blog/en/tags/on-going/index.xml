<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>On-going on Yet, another infosec blog</title>
    <link>https://legiahuyy.github.io/blog/en/tags/on-going/</link>
    <description>Recent content in On-going on Yet, another infosec blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 05 Jul 2021 09:30:00 +1345</lastBuildDate><atom:link href="https://legiahuyy.github.io/blog/en/tags/on-going/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PRE Solutions Series: First Chapter</title>
      <link>https://legiahuyy.github.io/blog/en/posts/pre-c1-e1/</link>
      <pubDate>Mon, 05 Jul 2021 09:30:00 +1345</pubDate>
      
      <guid>https://legiahuyy.github.io/blog/en/posts/pre-c1-e1/</guid>
      <description>As promised, this is the beginning of our solutions for the book Practical Reverse Engineering I had mentioned earlier. The utmost objective is to solve and provide concrete explanations for each topic.
The target audiences are believed to:
 Be familiar with basic mid-level programming language Have at least a fundamental understanding of computer architecture (CPU, RAM, etc.) Be determined to learn and do exercises in the book  And please be noticed that all of these solutions here are explained in my own comprehension and experience as there may have been some miscalculations and inaccuracies therein; hence, readers are recommended to review and reproduce these solutions if possible.</description>
      <content>&lt;p&gt;As promised, this is the beginning of our solutions for the book &lt;em&gt;Practical Reverse Engineering&lt;/em&gt; I had mentioned earlier. The utmost objective is to solve and provide concrete explanations for each topic.&lt;/p&gt;
&lt;p&gt;The target audiences are believed to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Be familiar with basic mid-level programming language&lt;/li&gt;
&lt;li&gt;Have at least a fundamental understanding of computer architecture (CPU, RAM, etc.)&lt;/li&gt;
&lt;li&gt;Be determined to learn and do exercises in the book&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And please be noticed that all of these solutions here are explained in &lt;em&gt;my own comprehension and experience&lt;/em&gt; as there may have been some miscalculations and inaccuracies therein; hence, readers are recommended to review and reproduce these solutions if possible.&lt;/p&gt;
&lt;p&gt;Without further ado, I hope you enjoy the post.&lt;/p&gt;
&lt;h2 id=&#34;basic-concepts&#34;&gt;Basic concepts&lt;/h2&gt;
&lt;p&gt;Before going any deeper, we have to understand initial concepts about registers, data types, and calling conventions. The book has already covered these definitions in a much more detailed version; it is nonetheless worth going through the vital parts again.&lt;/p&gt;
&lt;p&gt;The explanations will be provided in x86 flavor first, then in x64 or ARM to make it easier for beginners.&lt;/p&gt;
&lt;h3 id=&#34;general-purpose-registers&#34;&gt;General Purpose Registers&lt;/h3&gt;
&lt;p&gt;In protected mode, where virtual memory and paging are supported, the x86 architecture has eight 32-bit general-purpose-registers (GPRs): &lt;code&gt;EAX, EBX, EDX, ECX, EDI, ESI, EBP, ESP&lt;/code&gt;. And some can be further divided into 8- and 16-bit registers such as &lt;code&gt;AX, AL, SI, DI,...&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The following table presents common GPRs and their general usages:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Register&lt;/th&gt;
&lt;th&gt;Purpose&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ECX&lt;/td&gt;
&lt;td&gt;Loop counter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EDI&lt;/td&gt;
&lt;td&gt;String-destination operations&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ESI&lt;/td&gt;
&lt;td&gt;String-source operations&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EBP&lt;/td&gt;
&lt;td&gt;Base frame pointer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ESP&lt;/td&gt;
&lt;td&gt;Stack pointer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EAX, EBX, EDX&lt;/td&gt;
&lt;td&gt;Computing operations or storing data&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;data-types&#34;&gt;Data types&lt;/h3&gt;
&lt;p&gt;As you may already know,  there are common data types such as &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, or variable classifications in general. Each of them has a specific size in the memory, which we can evaluate using the &lt;code&gt;sizeof&lt;/code&gt; operator (ex. &lt;code&gt;sizeof(int) results in 4&lt;/code&gt;). This is also applied to our assembly registers without any significant difference.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Data-type&lt;/th&gt;
&lt;th&gt;Size&lt;/th&gt;
&lt;th&gt;Register&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;td&gt;8 bits&lt;/td&gt;
&lt;td&gt;AL, CL, BL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Word&lt;/td&gt;
&lt;td&gt;16 bits&lt;/td&gt;
&lt;td&gt;AX, BX, CX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Double Word&lt;/td&gt;
&lt;td&gt;32 bits&lt;/td&gt;
&lt;td&gt;EAX, EBX, ECX&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Quad Word&lt;/td&gt;
&lt;td&gt;64 bits&lt;/td&gt;
&lt;td&gt;EDX:EAX&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Speaking in x86, &lt;code&gt;Qword&lt;/code&gt; is not available on this architecture but it can combine two 32-bit registers, usually &lt;code&gt;EDX:EAX&lt;/code&gt;, to contain a 64-bit value in some scenarios.&lt;/p&gt;
&lt;h3 id=&#34;calling-conventions&#34;&gt;Calling conventions&lt;/h3&gt;
&lt;p&gt;In C/C++, we have seen some common calling conventions: &lt;code&gt;__cdecl&lt;/code&gt;, &lt;code&gt;__stdcall&lt;/code&gt; or &lt;code&gt;__fastcall&lt;/code&gt;. These so-called conventions are multiple sets of rules dictating how function calls work at the machine level. For example, should parameters be passed through the stack or registers? And should they be passed in left-to-right or right-to-left order?&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;CDECL&lt;/th&gt;
&lt;th&gt;STDCALL&lt;/th&gt;
&lt;th&gt;FASTCALL&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Parameters&lt;/td&gt;
&lt;td&gt;right-to-left&lt;/td&gt;
&lt;td&gt;right-to-left&lt;/td&gt;
&lt;td&gt;right-to-left&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Stack&lt;/td&gt;
&lt;td&gt;Caller must clean up the stack after call&lt;/td&gt;
&lt;td&gt;Callee must clean up the stack after call&lt;/td&gt;
&lt;td&gt;Besides the first two parameters, all are on the stack.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Return&lt;/td&gt;
&lt;td&gt;Stored in EAX&lt;/td&gt;
&lt;td&gt;Stored in EAX&lt;/td&gt;
&lt;td&gt;Stored in EAX&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;exercise-1---page-11&#34;&gt;Exercise 1 - Page 11&lt;/h2&gt;
&lt;p&gt;Below is our assignment.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This function uses a combination SCAS and STOS to do its work. First, explain what is the type of &lt;code&gt;[EBP+8]&lt;/code&gt; and &lt;code&gt;[EBP+C]&lt;/code&gt; in line 1 and 8, respectively. Next explain what this snippet does.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;01: 8B 7D 08    mov edi, [ebp+8]
02: 8B D7       mov edx, edi
03: 33 C0       xor eax, eax
04: 83 C9 FF    or ecx, 0FFFFFFFFh
05: F2 AE       repne scasb
06: 83 C1 02    add ecx, 2
07: F7 D9       neg ecx
08: 8A 45 0C    mov al, [ebp+0Ch]
09: 8B AA       mov edi, edx
10: F3 AA       rep stosb
11: 8B C2       mov eax, edx
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;[ebp+8]&lt;/code&gt; and &lt;code&gt;[ebp+0C]&lt;/code&gt; are the first and second parameters in the code snippet, respectively. It is assured because the convention will put our parameters on the stack before the &lt;code&gt;CALL&lt;/code&gt; instruction is executed.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/legiahuyy/image-host/main/2021-07-05-PRE-C1/stack.png&#34; alt=&#34;Function stack&#34;&gt;&lt;/p&gt;
&lt;p&gt;The types of &lt;code&gt;[ebp+8]&lt;/code&gt; and &lt;code&gt;[ebp+C]&lt;/code&gt; are most likely to be determined by the destination registers. In line 1, it is shown that the first parameter &lt;code&gt;[ebp+8]&lt;/code&gt; is stored in &lt;code&gt;EDI&lt;/code&gt;, which is commonly used in string operations and yet in line 8, the 8-bit register &lt;code&gt;AL&lt;/code&gt; stores our second parameter&lt;code&gt;[ebp+C]&lt;/code&gt; as a single byte value, ergo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[ebp+8]&lt;/code&gt; is of type &lt;code&gt;char*&lt;/code&gt; or null-terminated string&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[ebp+C]&lt;/code&gt; is of type &lt;code&gt;char&lt;/code&gt; or a single byte letter&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;snippet-walkthrough&#34;&gt;Snippet walkthrough&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;01: 8B 7D 08    mov edi, [ebp+8]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Simply copy the first parameter into &lt;code&gt;EDI&lt;/code&gt; from the stack.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;02: 8B D7       mov edx, edi&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Make a copy of &lt;code&gt;EDI&lt;/code&gt; into &lt;code&gt;EDX&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;03: 33 C0       xor eax, eax&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This operation sets &lt;code&gt;EAX&lt;/code&gt; to zero.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;04: 83 C9 FF    or ecx, 0FFFFFFFFh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Sets &lt;code&gt;ECX&lt;/code&gt; to &lt;code&gt;0xFFFFFFFF&lt;/code&gt; or, basically, &lt;code&gt;-1&lt;/code&gt; in decimal.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;05: F2 AE       repne scasb&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;REPNE SCASB&lt;/code&gt; instruction repeatedly scans and compares the byte of the accumulator (i.e. &lt;code&gt;EAX&lt;/code&gt;) against the present value pointed at by &lt;code&gt;EDI&lt;/code&gt;. It also decreases the counter &lt;code&gt;ECX&lt;/code&gt; and increases &lt;code&gt;EDI&lt;/code&gt; by one each in comparison.&lt;/p&gt;
&lt;p&gt;In simple terms, the mentioned instruction searches for the &lt;code&gt;NUL&lt;/code&gt; character in our string buffer. Please do remember that &lt;code&gt;ECX&lt;/code&gt; contains the length of our string plus two (incl. the &lt;code&gt;NUL&lt;/code&gt; byte and an uninitialized/unknown element after it) in negative form. For instance, if our string was 100 characters in length, &lt;code&gt;ECX&lt;/code&gt; would be &lt;code&gt;-102&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;06: 83 C1 02    add ecx, 2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Add 2 to &lt;code&gt;ECX&lt;/code&gt; and thus equal to the length of our string in the negative (incl. the &lt;code&gt;NUL&lt;/code&gt; character).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;07: F7 D9       neg ecx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Negates the value of &lt;code&gt;ECX&lt;/code&gt;, so it is two&amp;rsquo;s complement negation. &lt;code&gt;ECX = -(-100) = 100&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;08: 8A 45 0C    mov al, [ebp+0Ch]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Copy the second parameter to &lt;code&gt;AL&lt;/code&gt; register.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;09: 8B AA       mov edi, edx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;As &lt;code&gt;EDI&lt;/code&gt; was modified (increased in line 5), thereafter the register no longer points at the string buffer. Thus, this resets &lt;code&gt;EDI&lt;/code&gt; with the copied version of itself, &lt;code&gt;EDX&lt;/code&gt;, in line 2 so that it can be used again in the following line.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;10: F3 AA       rep stosb&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;STOSB&lt;/code&gt; is mostly the same as &lt;code&gt;SCASB&lt;/code&gt; except that it writes the value of the accumulator (i.e. &lt;code&gt;AL&lt;/code&gt;), repeatedly &lt;code&gt;ECX&lt;/code&gt; times, to &lt;code&gt;EDI&lt;/code&gt;. On that account, line 10 instruction replaces our entire buffer with the value of the second parameter.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;11: 8B C2       mov eax, edx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EAX&lt;/code&gt; is now holding the address of our modified string buffer.&lt;/p&gt;
&lt;h3 id=&#34;pseudo-c-code&#34;&gt;Pseudo-C code&lt;/h3&gt;
&lt;p&gt;The following snippet demonstrates the function.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;exercise1_page11&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; param1, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; param2) 
{
  &lt;span style=&#34;color:#75715e&#34;&gt;// get the length of param1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; strlen(param1);
  &lt;span style=&#34;color:#75715e&#34;&gt;// replace each character in the buffer with param2
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  memset(param1, param2, len);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; param1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
    </item>
    
  </channel>
</rss>
